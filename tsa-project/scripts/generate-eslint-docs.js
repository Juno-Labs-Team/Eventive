#!/usr/bin/env node
import { ESLint } from 'eslint';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const PROJECT_ROOT = path.join(__dirname, '..');
const OUTPUT_FILE = path.join(PROJECT_ROOT, 'ESLINT_RULES.md');

/**
 * fetch rule documentation from various sources
 */
async function fetchRuleDocumentation(ruleId, meta) {
  const docs = meta?.docs || {};
  
  return {
    description: docs.description || 'no description available.',
    url: docs.url || null,
    recommended: docs.recommended || false,
    category: docs.category || 'uncategorized',
    fixable: meta?.fixable || false,
    hasSuggestions: meta?.hasSuggestions || false,
  };
}

/**
 * categorize rules by their plugin/source
 */
function categorizeRule(ruleId) {
  if (ruleId.startsWith('@typescript-eslint/')) {
    return { category: 'typescript', plugin: 'typescript-eslint' };
  } else if (ruleId.startsWith('react-hooks/')) {
    return { category: 'react hooks', plugin: 'react-hooks' };
  } else if (ruleId.startsWith('react-refresh/')) {
    return { category: 'react refresh', plugin: 'react-refresh' };
  } else if (ruleId.startsWith('react/')) {
    return { category: 'react', plugin: 'react' };
  } else {
    return { category: 'javascript core', plugin: 'eslint' };
  }
}

/**
 * format rule configuration value
 */
function formatRuleConfig(config) {
  if (Array.isArray(config)) {
    const [severity, ...options] = config;
    return {
      severity: severity === 2 ? 'error' : severity === 1 ? 'warn' : 'off',
      options: options.length > 0 ? options : null
    };
  }
  return {
    severity: config === 2 ? 'error' : config === 1 ? 'warn' : 'off',
    options: null
  };
}

/**
 * generate markdown documentation
 */
function generateMarkdown(rulesByCategory, metadata) {
  const timestamp = new Date().toISOString().split('T')[0];
  
  let markdown = `# eslint rules documentation

> **auto-generated**: ${timestamp}
> 
> this document is automatically generated from the eslint configuration.
> any manual changes will be overwritten on the next update.

## table of contents

`;

  // generate toc
  for (const [category, rules] of Object.entries(rulesByCategory)) {
    const anchor = category.toLowerCase().replace(/\s+/g, '-');
    markdown += `- [${category} (${rules.length} rules)](#${anchor})\n`;
  }

  markdown += `\n---\n\n`;
  markdown += `## configuration summary\n\n`;
  markdown += `- **total rules**: ${metadata.totalRules}\n`;
  markdown += `- **error level**: ${metadata.errorCount}\n`;
  markdown += `- **warning level**: ${metadata.warnCount}\n`;
  markdown += `- **file patterns**: \`${metadata.filePatterns.join('`, `')}\`\n`;
  markdown += `- **ignored paths**: \`${metadata.ignoredPaths.join('`, `')}\`\n\n`;
  markdown += `---\n\n`;

  // generate sections for each category
  for (const [category, rules] of Object.entries(rulesByCategory)) {
    const anchor = category.toLowerCase().replace(/\s+/g, '-');
    markdown += `## ${category}\n\n`;
    
    rules.sort((a, b) => a.ruleId.localeCompare(b.ruleId));
    
    for (const rule of rules) {
      const { ruleId, config, docs } = rule;
      
      markdown += `### \`${ruleId}\`\n\n`;
      
      // severity badge
      markdown += `**severity**: ${config.severity}`;
      
      if (docs.recommended) {
        markdown += ` | recommended`;
      }
      if (docs.fixable) {
        markdown += ` | fixable`;
      }
      markdown += `\n\n`;
      
      // description
      markdown += `**description**: ${docs.description}\n\n`;
      
      // documentation link
      if (docs.url) {
        markdown += `[view rule documentation](${docs.url})\n\n`;
      }
      
      // options if any
      if (config.options) {
        markdown += `**options**:\n\`\`\`json\n${JSON.stringify(config.options, null, 2)}\n\`\`\`\n\n`;
      }
      
      markdown += `---\n\n`;
    }
  }

  // add footer
  markdown += `## how to update this documentation\n\n`;
  markdown += `this file is automatically generated. to update:\n\n`;
  markdown += `1. **automatic**: runs on every push that changes \`eslint.config.js\` or \`package.json\`\n`;
  markdown += `2. **manual**: run \`npm run generate-eslint-docs\`\n`;
  markdown += `3. **manual (github actions)**: go to actions → "update eslint rules documentation" → run workflow\n\n`;
  markdown += `## resources\n\n`;
  markdown += `- [eslint documentation](https://eslint.org/docs/latest/)\n`;
  markdown += `- [typescript eslint](https://typescript-eslint.io/)\n`;
  markdown += `- [react hooks rules](https://react.dev/reference/rules/rules-of-hooks)\n`;
  markdown += `- [react fast refresh](https://github.com/facebook/react/tree/main/packages/react-refresh)\n\n`;
  markdown += `---\n\n`;
  markdown += `**last generated**: ${new Date().toISOString()}\n`;

  return markdown;
}

/**
 * main function to generate documentation
 */
async function main() {
  console.log('analyzing eslint configuration...\n');

  try {
    // initialize eslint with the project's config
    const eslint = new ESLint({
      cwd: PROJECT_ROOT,
      overrideConfigFile: path.join(PROJECT_ROOT, 'eslint.config.js'),
    });

    // get the calculated config for a typescript file
    const config = await eslint.calculateConfigForFile('src/App.tsx');
    
    console.log('configuration loaded successfully\n');

    const rules = config.rules || {};
    const rulesByCategory = {};
    const metadata = {
      totalRules: 0,
      errorCount: 0,
      warnCount: 0,
      filePatterns: ['**/*.ts', '**/*.tsx'],
      ignoredPaths: ['dist']
    };

    // process each rule
    for (const [ruleId, ruleConfig] of Object.entries(rules)) {
      // skip disabled rules
      if (ruleConfig === 'off' || ruleConfig === 0 || 
          (Array.isArray(ruleConfig) && (ruleConfig[0] === 'off' || ruleConfig[0] === 0))) {
        continue;
      }

      metadata.totalRules++;

      // get rule metadata
      let ruleMeta = null;
      try {
        // try to get the actual rule object from eslint
        const ruleModule = await eslint.getRulesMetaForResults([{
          filePath: path.join(PROJECT_ROOT, 'src/App.tsx'),
          messages: [],
          suppressedMessages: [],
          errorCount: 0,
          fatalErrorCount: 0,
          warningCount: 0,
          fixableErrorCount: 0,
          fixableWarningCount: 0,
          usedDeprecatedRules: []
        }]);
        
        ruleMeta = ruleModule[ruleId];
      } catch (e) {
        // fallback if we can't get meta
        console.warn(`could not fetch metadata for rule: ${ruleId}`);
      }

      const config = formatRuleConfig(ruleConfig);
      const docs = await fetchRuleDocumentation(ruleId, ruleMeta);
      const { category } = categorizeRule(ruleId);

      if (config.severity === 'error') metadata.errorCount++;
      if (config.severity === 'warn') metadata.warnCount++;

      if (!rulesByCategory[category]) {
        rulesByCategory[category] = [];
      }

      rulesByCategory[category].push({
        ruleId,
        config,
        docs
      });
    }

    console.log(`found ${metadata.totalRules} active rules:\n`);
    for (const [category, rules] of Object.entries(rulesByCategory)) {
      console.log(`   ${category}: ${rules.length} rules`);
    }
    console.log();

    // generate markdown
    console.log('generating markdown documentation...\n');
    const markdown = generateMarkdown(rulesByCategory, metadata);

    // write to file
    await fs.writeFile(OUTPUT_FILE, markdown, 'utf-8');
    
    console.log('documentation generated successfully!\n');
    console.log(`output: ${path.relative(process.cwd(), OUTPUT_FILE)}\n`);

  } catch (error) {
    console.error('error generating documentation:', error);
    process.exit(1);
  }
}

main();